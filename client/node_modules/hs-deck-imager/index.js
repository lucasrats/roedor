const path = require('path');
const Jimp = require('jimp');
const Deckstring = require('deckstrings');
const loadJsonFile = require('load-json-file');

const HEROES = {
  7: 'Warrior',       // Garrosh
  2828: 'Warrior',    // Magni
  1066: 'Shaman',     // Thrall
  40183: 'Shaman',    // Morgl
  930: 'Rogue',       // Valeera
  40195: 'Rogue',     // Maiev
  671: 'Paladin',     // Uther
  2827: 'Paladin',    // Liadrin
  46116: 'Paladin',   // Arthas
  31: 'Hunter',       // Rexxar
  2826: 'Hunter',     // Alleria
  274: 'Druid',       // Malfurion
  893: 'Warlock',     // Gul'dan
  47817: 'Warlock',   // Nimsy
  637: 'Mage',        // Jaina
  2829: 'Mage',       // Either Medivh or Khadgar, idk
  39117: 'Mage',      // The other one
  813: 'Priest',      // Anduin
  41887: 'Priest'     // Tyrande
};

const FORMATS = {
  1: 'Wild',
  2: 'Standard',
};

const IMG_W = 243; // Width of the image; based on width of hero tile
const HERO_H = 97; // Height of hero tile; serves as offset for card tiles
const TILE_H = 34; // Height of card tiles

const DECK_TITLE_X = 20; // X position of deck title
const DECK_TITLE_Y = 50; // Y position of deck title

const TILE_OFFSET = 15; // X offset of the card tile
                        // (displayed under a container)

const TILE_SCALE_FACTOR = .85; // Factor by which to scale card tiles

const MANA_SINGLE_DIGIT_OFFSET = 9; // X offset for single digit mana costs
const MANA_DOUBLE_DIGIT_OFFSET = 2; // X offset for double digit mana costs
const MANA_Y_OFFSET = 3; // Y offset for centering mana placement

const CARD_TEXT_X_OFFSET = 38; // X offset for card tile text
const CARD_TEXT_Y_OFFSET = 10; // Y offset for card tile text

const STAR_X_OFFSET = 24; // X offset for legendary star (if applicable)
const STAR_Y_OFFSET = 8; // Y offset for legendary star (if applicable)

const COPY_TEXT_X_OFFSET = 21; // X offset for number of copies (if applicable)
const COPY_TEXT_Y_OFFSET = 5; // Y offset for number of copies (if applicable)

const titleFontPath = path.join(__dirname, 'resources/fonts/hs24.fnt');
const manaFontPath = path.join(__dirname, 'resources/fonts/hs24.fnt');
const cardFontPath = path.join(__dirname, 'resources/fonts/hs16.fnt');
const numFontPath = path.join(__dirname, 'resources/fonts/hs20.fnt');

let titleFont, manaFont, cardTextFont, copyNumFont;

let star, container;

async function loadConstants(){
  // Load fonts
  if(titleFont == null){
    titleFont = await Jimp.loadFont(titleFontPath);
  }
  if(manaFont == null){
    manaFont = await Jimp.loadFont(manaFontPath);
  }
  if(cardTextFont == null){
    cardTextFont = await Jimp.loadFont(cardFontPath);
  }
  if(copyNumFont == null){
    copyNumFont = await Jimp.loadFont(numFontPath);
  }

  // Load container and star images
  if(container == null){
    container = (await Jimp.read(
      path.join(__dirname, 'resources/tile_container_number.png')
    )).resize(IMG_W, TILE_H);
  }
  if(star == null){
    star = await Jimp.read(
      path.join(__dirname, 'resources/star.png')
    );
  }
}

/**
 *
 * @param deckstring Hearthstone deckstring to turn into an image
 * @param outputFile destination and name where image will be saved
 * @returns {Promise<String>} String if the image was successfully created
 *    and resolved; otherwise, the promise will reject with an error message
 */
function imageFromDeckstring(deckstring, outputFile){
  return new Promise(async function(resolve, reject){
    // Track what cards exist in the player's deck
    let cards = [];
    try {
      // Parse deck information
      const deckInfo = Deckstring.decode(deckstring);
      const format = FORMATS[deckInfo.format];
      const hero = HEROES[deckInfo.heroes[0]];

      // Load all collectible cards
      const hsCards = await loadJsonFile(
        path.join(__dirname, './resources/cards.collectible.json')
      );

      // Find our cards in the dictionary
      for (let i = 0; i < deckInfo.cards.length; i++) {
        for (let j = 0; j < hsCards.length; j++) {
          // Find each card in the deck in the HS database
          if (hsCards[j]['dbfId'] === deckInfo.cards[i][0]) {
            cards.push([
              hsCards[j]['name'],             // Name of card
              deckInfo.cards[i][1],           // Number of copies
              hsCards[j]['cost'],             // Cost of card
              hsCards[j]['elite'] === true,   // Is legendary?
              hsCards[j]['id'] + '.png'       // Tile name
            ]);
          }
        }
      }

      // Sort the decklist such that lower cost cards come first
      cards.sort(function (a, b) {
          // If the cards have the same mana cost, compare names
          if (a[2] === b[2]) {
            let i = 0;
            // Progress forward through the string
            // until a different char appears
            while (a[0][i] === b[0][i]) {
              i++;
            }
            // Subtract ASCII values to find the smaller
            return a[0].charCodeAt(i) - b[0].charCodeAt(i);
          }

          // If cards have differing manacosts, find the smaller
          return a[2] - b[2];
        }
      );

      let uniqueCount = cards.length;

      // Load our fonts and container/star images
      await loadConstants();

      if(
        titleFont == null || manaFont == null ||
        cardTextFont == null || copyNumFont == null
      ){
        return reject('Could not load font files.');
      }

      // Create a new image
      // The size of the image is based on how many unique cards are in the deck
      let img = new Jimp(IMG_W, uniqueCount * TILE_H + HERO_H);

      if (img == null) {
        return reject('Could not create new Jimp image.');
      }

      // Load the hero header image
      const heroHeader = await Jimp.read(
        path.join(__dirname, 'resources/' + hero.toLowerCase() + '.jpg')
      );

      if (heroHeader == null) {
        return reject('Could not find the hero tile for class ' + hero + '.');
      }

      // Add the hero header to the image at the origin
      img = await img.composite(heroHeader, 0, 0);

      // Add the text title text over the header
      const deckTitle =
        img.print(titleFont, DECK_TITLE_X, DECK_TITLE_Y, format + ' ' + hero);
      if (deckTitle == null) {
        return reject('Could not print deck title.');
      }

      // For every unique card in the deck, add a new tile
      for (let i = 0; i < uniqueCount; i++) {
        // Load and resize the card's tile
        let tile = await Jimp.read(
          path.join(__dirname, 'resources/card-tiles/' + cards[i][4])
        );
        tile = tile.cover(IMG_W * TILE_SCALE_FACTOR, TILE_H);

        // Add the tile to the image, then overlay the tile container
        img = await img.composite(tile, TILE_OFFSET, HERO_H + i * TILE_H);
        img = await img.composite(container, 0, HERO_H + i * TILE_H);

        // If a card has double digit mana cost,
        // offset appropriately so its centered
        const manaOffset = cards[i][2] > 9 ?
          MANA_DOUBLE_DIGIT_OFFSET :
          MANA_SINGLE_DIGIT_OFFSET;

        // Print the mana cost of the card
        const manaText = img.print(
          manaFont,
          manaOffset,
          HERO_H + i * TILE_H + MANA_Y_OFFSET,
          cards[i][2] + ''
        );
        if (manaText == null) {
          return reject('Could not print mana text of card.');
        }

        // If the card name is too long to fit ("Lesser Amethyst Spellstone")
        // chop it and add an ellipsis
        let cardName = cards[i][0];
        cardName = cardName.length > 20 ?
          cardName.slice(0, 19) + '...' :
          cardName;

        // Print the card's name
        const cardNameText = img.print(
          cardTextFont,
          CARD_TEXT_X_OFFSET,
          HERO_H + i * TILE_H + CARD_TEXT_Y_OFFSET,
          cardName
        );
        if (cardNameText == null) {
          return reject('Could not print name of card.');
        }

        // If the card is a legendary, draw a star
        if (cards[i][3] === true) {
          img = await img.composite(
            star,
            IMG_W - STAR_X_OFFSET,
            HERO_H + i * TILE_H + STAR_Y_OFFSET
          );
        }
        // Otherwise, list how many copies are in the deck
        else {
          const numCopyText = img.print(
            copyNumFont,
            IMG_W - COPY_TEXT_X_OFFSET,
            HERO_H + i * TILE_H + COPY_TEXT_Y_OFFSET,
            cards[i][1] + ''
          );

          if (numCopyText == null) {
            return reject('Could not print number of copies of card.');
          }
        }
      }

      // Save our completed image
      img.write(outputFile).then(resolve(outputFile));
    }
    catch(exception){
      return reject(exception);
    }
  });
}

module.exports = {
  imageFromDeckstring
}
